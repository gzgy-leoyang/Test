
# 自动测试工具

- [概述](#概述)
  - [背景](#背景)
  - [术语及概念](#术语及概念)
  - [基本思路](#基本思路)
  - [硬件环境](#硬件环境)
    - [被测设备](#被测设备)
    - [测试控制器](#测试控制器)
    - [其他设备](#其他设备)
  - [软件环境](#软件环境)
    - [测试服务端](#测试服务端)
    - [测试客户端](#测试客户端)
- [被测设备(新开发平台)](#被测设备新开发平台)
  - [测试服务(yqsrv\_testd)](#测试服务yqsrv_testd)
    - [启动yqsrv\_testd进程](#启动yqsrv_testd进程)
    - [UDS访问协议](#uds访问协议)
      - [帧ID定义](#帧id定义)
      - [首字节](#首字节)
      - [单帧数据读写](#单帧数据读写)
      - [会话模式](#会话模式)
      - [安全访问](#安全访问)
    - [SID号段划分](#sid号段划分)
    - [系统参数接口](#系统参数接口)
    - [yqsrv\_ignition服务接口(Orchid)](#yqsrv_ignition服务接口orchid)
    - [yqsrv\_launcher服务接口(Launcher)](#yqsrv_launcher服务接口launcher)
    - [yqsrv\_hourmeter服务接口(Hyman)](#yqsrv_hourmeter服务接口hyman)
    - [按键和触摸屏](#按键和触摸屏)
    - [MCU 功能](#mcu-功能)
    - [显存像素检查](#显存像素检查)
  - [启动标记](#启动标记)
- [测试控制器(诊断测试)](#测试控制器诊断测试)
  - [测试客户端进程 (Spy-station)](#测试客户端进程-spy-station)
    - [启动客户端进程](#启动客户端进程)
    - [测试脚本(\*.process)](#测试脚本process)
      - [系统测试命令](#系统测试命令)
      - [yqsrv\_ignition(Orchid)服务进程测试命令](#yqsrv_ignitionorchid服务进程测试命令)
      - [yqsrv\_launcher(Launcher)服务进程测试命令](#yqsrv_launcherlauncher服务进程测试命令)
      - [yqsrv\_hourmeter(Hyman)服务进程测试命令](#yqsrv_hourmeterhyman服务进程测试命令)
      - [触摸屏测试命令](#触摸屏测试命令)
      - [yqsrv\_keypad(Kemp)服务进程测试命令](#yqsrv_keypadkemp服务进程测试命令)
      - [MCU测试命令](#mcu测试命令)
      - [背光测试命令](#背光测试命令)
      - [CAN测试命令](#can测试命令)
      - [电源控制命令](#电源控制命令)
      - [其他控制命令](#其他控制命令)
      - [显示像素测试命令](#显示像素测试命令)
    - [测试记录](#测试记录)
      - [事件记录](#事件记录)
      - [过程参数记录](#过程参数记录)
      - [视频或图片记录](#视频或图片记录)
- [CAN扩展IO](#can扩展io)
  - [开关量输出](#开关量输出)
  - [开关量输入](#开关量输入)
- [生产测试工具(Hunter,硬件测试)](#生产测试工具hunter硬件测试)

## 概述

### 背景

基于Linux平台的软硬件环境相对比较复杂,在多进程(多线程)以及多核处理器的环境下,有一些潜在的,小概率故障可能是在短时间的设计/测试环节比较难发现的.
其次,当某些小概率故障被识别并修复后,也需要一个仿真环境长期运行验证.
基于以上的理由,本文尝试构建一套用于Linux产品线的测试验证环境.

### 术语及概念

- 测试控制器,一个测试环境中运行"测试客户端"进程的主机,当前位于一台i6的显示器,后续可扩展到x86/Win平台用于生成和客户测试工具.该进程主导测试过程,判断测试结果并记录过程数据供后续分析.下文对以下术语不做区分:测试控制器,测试控制器,诊断控制设备,诊断仪
- 被测设备,运行"测试服务端"进程的设备,一个测试环境中通常包含多台源地址不同的被测设备.

### 基本思路

区别于测试组实施的人工黑/白盒测试,自动黑盒测试力图于将被测试设备置于给定工作环境中,反复运行并检测每一个工作循环的结果.应该实现以下的关键特征或功能:
- 外部接口全部处于工作状态,比如ACC/BAT收到控制,CAN/LIN总线持续收发数据,链接全部视频输入;
- 内部功能尽可能处于较高负载运行状态,比如:反复执行2D/3D动画提升GPU压力;使用较高的CAN总线负载输入提升被测试设备的软件负载;
- 控制外部工作环境使被测试设备达到或略高于标称条件的气候环境;
- 由于测试需要长期连续运行,且关键特性具备较高权重,故对其的判断必须应该考虑必要的冗余手段,以避免由于外部条件的意外变化导致高权重检测条件误判;

### 硬件环境
完整的硬件环境包含测试控制设备(控制和状态采集)及被测试设备组,通过CAN总线扩展电源控制和背光亮度采集通道,同时CAN通道还用于链接被测试设备与测试控制器中的测试工具软件.

![](file:////tmp/wps-dd/ksohtml/wpsIPQYNk.jpg) 

#### 被测设备

被测设备通常即是新开发产品或平台,与普通设备的主要差异在于:

l 集中部署并运行需测试的全部组件,而实际项目中通常不会全部使用;

l 以中间服务组件的形式添加“测试服务端进程”,等待来自“测试客户端”的请求并执行正/负应答;

![](file:////tmp/wps-dd/ksohtml/wpsXXuipL.jpg) 

测试客户端通过以下两类接口链接系统或服务:

l 通过sys/或proc/ 获取操作系统和驱动的信息

l 通过各服务的dbus/tmpfs/shared mem 获取进程(中间服务和UI)的运行状态

获取所需信息状态后,通过CAN/UDS协议接口(目前主要采用SID:0x22)向发出请求的客户端返回查询结果.

外部设置操作也可通过UDS协议,通过“ 会话控制”及“ 安全访问”进行鉴权后开放某些高级别的读写操作.

#### 测试控制器

测试控制器可运行于PC平台(Linux/Windows),也可运行在嵌入式Linux设备,其中运行包含UI界面的测试客户端,该进程以“ 一对多”的方式,通过CAN网络链接若干测试服务端,重复执行既定的测试流程,一个基本的循环通常包括:启动,查询,检验和记录,关机,整个测试流程可指定随机时间完成.

![](file:////tmp/wps-dd/ksohtml/wps7GjULP.jpg) 

#### 其他设备

在测试环境中,如果需要对显示器上下电的完整控制,可通过“ 继电器干接点”控制ACC和BAT的信号,考虑到被测试设备组的数量和功耗,干接点触点容量不应小于DC24V/5A,并支持通过CAN/EtherNet控制.

如果需要对背光状态的反馈检测,可加入“亮度传感器模块”,以开关量的形式返回当前被测试设备屏幕的亮度状态.

传感器模块由于使用比较器(正反馈运放),实现了较好的“回差特性”,相较于直接采样光敏电阻应该具有更好的抗环境光线扰动的能力.

![](file:////tmp/wps-dd/ksohtml/wpsTfm08a.jpg) 

因为开关机和背光控制功能对用户的正常使用影响较大,可认为是设备的比较关键的特性,建议对这类信号的测量采取必要的冗余和反馈校验措施,在正确识别异常的同时,减少外部设备异常导致的误判.

### 软件环境

自动测试的实现采用“客户端-服务器”模式(CS)的测试工具,如下:

#### 测试服务端

被测试设备中默认启动 yqsrv_testd 测试工具服务端(无界面),可同时运行用于生产环境的功能测试UI进程进行观察. yqsrv_testd 测试工具的软件结构如下:

l 顶层包含若干服务适配器,用于链接各种被测试进程

l 中部包含UDS管理器,实现UDS协议功能

l 下部包含多个CAN网络对象,链接中部UDS协议功能

![](file:////tmp/wps-dd/ksohtml/wpseXJZ5t.jpg) 

![](file:////tmp/wps-dd/ksohtml/wpsUtFAqs.png) 

#### 测试客户端

测试客户端运行于一台imx6显示器,包含图形化界面的多线程程序,基本结构如下:

l 顶层使用QML描述界面,接收用户输入操作等;
l 中部为各页面添加对应的业务逻辑功能;
l 底部使用回调函数处理收到的UDS应答,使用[时刻-操作]队列定义一次完整的测试过程和判断条件等.

![](file:////tmp/wps-dd/ksohtml/wpsauzmpN.jpg) 

测试客户端需要承担一个非常重要的功能——过程记录,目前以*.cvs文件为载体,由区分信息等级(正常.警告和错误)的日志记录组成,用于发现测试异常后的回溯.

![](file:////tmp/wps-dd/ksohtml/wpsqfJc1x.jpg) 


![](file:////tmp/wps-dd/ksohtml/wpslQlYrc.png)



## 被测设备(新开发平台)

被测设备开机后自动启动测试服务进程,通过该进程配合测试控制器完成指定测试过程.

### 测试服务(yqsrv_testd)

yqsrv_testd 进程部署于被测设备,作为测试回环中的"服务端",该进程启动后静默等待来自"测试客户端"的消息,并根据收到的请求内容执行动作,完成后以应答消息的方式返回测试结果.

[补充图片,测试进程和其他业务进程的简单关系]

#### 启动yqsrv_testd进程

```sh
#./yqsrv_testd -T 0 -S 1
```

> T:指定远端测试控制器地址为0
> S:指定本地被测设备地址为1
> p:指定本地被测设备链接测试控制器的CAN端口,缺省默认:can0

#todo-Dev 
- [x] yqsrv_testd 添加 -p 参数启动,指定使用的CAN端口

由于测试控制器和被测设备之间以CAN/UDS协议实现,故先简单说明UDS协议基本概念.

#### UDS访问协议

UDS协议是在应用层实现的一个诊断协议,主要是对CAN报文的8字节数据的"再定义".与J1939协议一样,可分为:单帧和多帧方式,在当前版本中主要采用单帧通讯为主,以下逐层说明:

##### 帧ID定义

UDS协议中使用的 CAN ID 由主机厂和OEM设备生产商定义.而本测试工具为了实现同时测试"多设备"的目标,修改CAN ID 的定义如下格式:

|ID[3]|[2]|[1]|[0]|
|--|--|--|--|
|0x0C|0xFE|DA目标地址|SA源地址|

通过 DA 和 SA 区分当前报文的接收方和发出方.

>举例:
> 由测试控制器(服务端)向1号被测设备发出的请求报文,其ID定义为0x0CFE0100,即:作为客户端的测试控制器寻址为0x00,作为服务器的被测试设备寻址0x01.
> 相反方向上,1号设备在收到请求,执行完成后发出的应答报文,其ID定义为0x0CFE0001,表明该消息来自1号设备,应该由00测试控制端接收处理.

##### 首字节

单帧方式下,首字节定义:
Bit[7..4] = 0,Bit[3..0]=Data Length

多帧方式下,首字节可分为:

- 首帧,前两个字节中,Bit[15..12]=1,Bit[11..0]=Data Length，控制信息共占用2个字节。举例：Data 10 14 2E F1 90 01 02 03，0x014表示多帧组合共有20个字节。
- 流控制帧,前三个字节为 Bit[23..20]=3,Bit[19..16]=流状态（FS）,Bit[15..8]=块大小（BS）,Bit[7..0]=最小间隔时间（STmin），举例：Data 30 00 14 AA AA AA AA AA，多帧发送方应知晓:流控帧允许继续发送
- 连续帧:第一个字节为2+SN（最多16个SN，溢出后从0开始重新计数），控制信息占用1个字节。常记首帧为0x20，之后的第一个连续帧自然是0x21，之后一直到0x2F，下一个是0x20，循环。

**当前版本中UDS协议仅使用单帧方式操作**

##### 单帧数据读写

测试控制器向被测设备发出如下格式的报文:

|ID|Byte[0]|[1]|[2]|[3]|[4]|[5]|[6]|[7]|
|--|--|--|--|--|--|--|--|--|
|0x0CFE0100|首字节(控制)|SID|DID低字节|DID高字节|||||
注:以上ID表明该报文从控制器00发往01被测设备

其中,SID域表明本次访问的"服务ID",标记所需要请求的服务功能,DID域描述对应的数据标识,当前版本测试工具主要使用如下SID:

|功能名|SID|数据域|说明|
|--|--|--|--|
|读数据|0x22|DID(2Byte)|向被测设备请求指定数据|
|写数据|0x2E|DID(2Byte)|向被测设备的指定参数写入指定值|

被测设备(服务端)的应答可分为正/肯定和负/否定的应答类型,以表明返回数据是否有效:

- 肯定的响应（Positive Response），首字节回复[SID+0x40]，举例:请求0x22，正响应0x62；
- 否定的响应（Negative Response），首字节固定回复0x7F，第二字节回复刚才询问的SID，第三字节是NRC(否定响应码)，代表被测设备执行否定应答的具体原因,比如:所请求的数据(DID)超出被测设备定义,亦或是指定的服务(SID)并没有完全实现。

被测试设备向测试控制器正/肯定应答报文:

|ID|Byte[0]|[1]|[2]|[3]|[4]|[5]|[6]|[7]|
|--|--|--|--|--|--|--|--|--|
|0x0CFE0001|首字节(控制)|SID|DID低字节|DID高字节|数据(最低)|数据|数据|数据(最高)|

注1:发出应答的被测设备地址为1,测试控制器地址为0
注2:假设该DID参数长度为4字节 

##### 会话模式

UDS协议中,采用"会话机制"协调测试控制器和被测设备的交互等级，在不同等级的会话中,诊断服务具有不同的执行的权限,可执行的操作也是不同的.
通常,测试控制器启动之后，会给被测设备发送[10 03]，让被测设备进入"扩展会话" ,进一步的,测试控制器可以固定间隔时间发送0x3E服务维持当前特定的会话模式。

**当前测试功能已提供永青使用的扩展模式(0x60),但目前实际测试过程还是处于"默认会话"状态,也就是不需要进入扩展即可执行读取访问.**

##### 安全访问

在UDS协议中,对某些关键数据的访问需要预先执行"授权解锁"的过程,即被测设备启动后默认处于"默认会话"且保持安全锁定状态.为了实现高级别数据的访问,需要首先切换到"非默认"会话,之后执行安全访问的鉴权流程,具体包括：

1. 测试控制器向被测试设备请求密钥种子
2. 被测设备向测试控制器应答发送密钥种子,同时被测设备内部计算密钥
3. 测试控制器向被测设备发送根据种子计算获得的密钥
4. 被测设备对比接收密钥与内部计算密钥,判断测试控制器是否合法访问

在完成以上过程后,被测试设备确认访问设备身份和权限后可开放关键参数和特殊操作方法调用.

**当前测试功能已提供安全访问机制,但目前实际测试过程不需要进入安全访问即可读取访问**

#### SID号段划分

当前版本测试工具按如下布局划分SID,后续可根据需要逐步添加.

|功能说明|号段|说明 |
|--|--|--|
|测试过程          | 0x8000 | 测试过程的记录 |
|系统参数          | 0x8100 | 查询SOC或是Linux系统提供的信息 |
|Orchid服务参数    | 0x8200 | 开关机服务 |
|Launcher服务参数  | 0x8300 | 进程监控服务 |
|Hourmeter服务参数 | 0x8400 | 小时计服务 |
|Input子系统参数   | 0x8600 | CAN按键和触摸屏 |
|MCU子系统参数     | 0x8700 | 访问协处理器 |
|显示部分参数     | 0x8800 | 读取显存内容 |

**以下的测试接口,均可在Win下通过CAN工具执行**
> 举例: 假设1号设备的CPUID为0x78563412,通过ZCANPro查询
> ZCANPro 发出: 0x1CFE0100,0x03 00 80 AA AA AA AA
> 被测试设备返回: 0x1CFE0001,0x07,62 00 80 12 34 56 78

|SID|DID|功能说明|会话模式|安全访问|数据内容 |备注 |
|--|--|--|--|--|--|--|
|无| 0x8001 | 累计启动循环计数      | 否  | 否 |4字节||
|无| 0x8002 | Testd应答超时计数    | 否 | 否 || |
|无| 0x8003 | 设备启动标记1CF0     | 否 | 否 || |
|无| 0x8004 | 设备启动标记1CF1     | 否 | 否 || |
|无| 0x8005 | TestD启动标记       | 否 | 否 || |

#### 系统参数接口

本节定义对 Soc/Linux 的公共状态参数的访问,后续可在SID号段[0x8000~0x80FF]范围内添加其他参数

|SID|DID|功能说明|会话模式|安全访问|数据内容 |备注 |
|--|--|--|--|--|--|--|
|0x22| 0x8100 | CPU ID       | 否  | 否 |4字节|芯片内部ID的最低4字节|
|0x22| 0x8101 | CPU 启动时间  | 否 | 否 |4字节,最小分辨1sec| |
|0x22| 0x8110 | 1min平均负载  | 否 | 否 |2字节,最小分辨0.01|Loadavg参数的100倍 |
|0x22| 0x8111 | 5min平均负载  | 否 | 否 |2字节,最小分辨0.01|Loadavg参数的100倍 |
|0x22| 0x8112 | 15min平均负载 | 否 | 否 |2字节,最小分辨0.01|Loadavg参数的100倍 |
|0x22| 0x8120 | CPU1 主频    | 否 | 否 |2字节,最小分辨1MHz| |
|0x22| 0x8121 | CPU2 主频    | 否 | 否 |2字节,最小分辨1MHz| |
|0x22| 0x8122 | CPU3 主频    | 否 | 否 |2字节,最小分辨1MHz| |
|0x22| 0x8123 | CPU4 主频    | 否 | 否 |2字节,最小分辨1MHz| |
|0x22| 0x8130 | 总内存       | 否 | 否 | 4字节,最小分辨1KB||
|0x22| 0x8131 | 可用内存      | 否 | 否 | 4字节,最小分辨1KB|AvaildMem|
|0x22| 0x8140 | CPU温度1     | 否 | 否 |1字节,最小分辨1摄氏度| |
|0x22| 0x8141 | CPU温度2     | 否 | 否 |1字节,最小分辨1摄氏度| |
|0x22| 0x8142 | 背光亮度      | 否 | 否 |1字节,0~255| |
|0x22| 0x8143 | 背光传感器反馈值| 否 | 否 |1字节,0~255| |
|0x22| 0x8150 | CAN0 RX计数  | 否 | 否 |4字节,最小分辨1帧| |
|0x22| 0x8151 | CAN0 TX计数  | 否 | 否 |4字节,最小分辨1帧| |

#### yqsrv_ignition服务接口(Orchid)

yqsrv_ignition服务用于监视ACC状态,并根据设定参数控制液晶背光和关机

|SID|DID|功能说明|会话模式|安全访问|数据内容 |备注 |
|--|--|--|--|--|--|--|
|0x22| 0x8201 | ACC点火开关状态| 否  | 否 |1字节 |0:ACC down |

#### yqsrv_launcher服务接口(Launcher)

yqsrv_launcher服务根据配置文件描述,监视相关的进程是否处于运行状态,当进程意外退出时立即重启该进程.

|SID|DID|功能说明|会话模式|安全访问|数据内容 |备注 |
|--|--|--|--|--|--|--|
|0x22| 0x8301 | Launcher重启应用计数 | 否  | 否 |1字节 | |
|0x22| 0x8302 | Launcher心跳        | 否  | 否 |1字节 | |

#### yqsrv_hourmeter服务接口(Hyman)

小时计服务实际存在三个不同版本,包括:

- yqsrv_hourmeter_zl,早期项目,用于中联项目中,采用共享内存方式访问;
- yqsrv_hourmeter_lv,早期项目,用于雷沃项目,采用tmpfs(/tmp/Hyman/second)接口访问;
- yqsrv_hourmeter,通用小时计,通过ini文件配置功能,采用tmpfs(/run/Hyman_work/second)接口访问;
通过各自的接口获取如下的测试参数:

|SID|DID|功能说明|会话模式|安全访问|数据内容 |备注 |
|--|--|--|--|--|--|--|
|0x22| 0x8400 | Hourmeter(Hyman_work)秒计数      | 否 | 否 |4字节 | |
|0x22| 0x8401 | Hourmeter_lv(Hyman)秒计数        | 否 | 否 |4字节 | |
|0x22| 0x8402 | Hourmeter_zl(hourmeter_qt)秒计数 | 否 | 否 |4字节 | |

#### 按键和触摸屏

通过子线程阻塞方式读取 ili2511和 kemp 对应的 /dev/input/eventX 文件生成所需要的如下的测试参数.

|SID|DID|功能说明|会话模式|安全访问|数据内容 |备注 |
|--|--|--|--|--|--|--|
|0x22| 0x8601 | F1键按下计数     | 否 | 否 |4字节| |
|0x22| 0x8602 | F1键释放计数     | 否 | 否 |4字节| |
|0x22| 0x8603 | 触摸按下计数     | 否 | 否 |4字节| |
|0x22| 0x8604 | 触摸释放计数     | 否 | 否 |4字节| |
|0x22| 0x8605 | 最近一次触摸坐标X | 否 | 否 |2字节| |
|0x22| 0x8606 | 最近一次触摸坐标Y | 否 | 否 |2字节| |

#### MCU 功能

通过调用 libmcuuart.so/mcu_ctrl.h 的接口获取MCU的测试参数,如下:

|SID|DID|功能说明|会话模式|安全访问|数据内容 |备注 |
|--|--|--|--|--|--|--|
|0x22| 0x8700 | MCU 固件版本   | 否 | 否 |2字节 | MCU固件版本 |
|0x22| 0x8701 | MCU 固件次版本 | 否 | 否 |2字节 | |
|0x22| 0x8702 | MCU 硬件版本   | 否 | 否 |2字节 | MCU通过ADC采样获取硬件版本 |
|0x22| 0x8703 | MCU 硬件次版本 | 否 | 否 |2字节 | |
|0x22| 0x8704 | MCU ACC电压   | 否 | 否 |2字节,最小分辨1mV | |
|0x22| 0x8705 | MCU BAT电压   | 否 | 否 |2字节,最小分辨1mV | |

#### 显存像素检查

|SID|DID|功能说明|会话模式|安全访问|数据内容 |备注 |
|--|--|--|--|--|--|--|
|0x22| 0x8800 | 读取指定位置的像素的RGB值  | 否 | 否 |4字节 | [5]=r,[6]=g [7]=b |
|0x22| 0x8801 | 指定位置的像素的X值  | 否 | 否 |4字节 | |
|0x22| 0x8802 | 指定位置的像素的Y值  | 否 | 否 |4字节 | |



### 启动标记

为了防止启动过程中 yqsrv_testd 错误而退出,导致诊断测试控制器不能收到任何数据而"误判系统启动失败"这类较严重的异常.所以单独添加"启动标记"功能,具体如下:

在系统启动后,通过shell脚本控制 cansend 工具发出扩展帧数据,以此表明当前系统正在启动或完成启动,为外部的测试环境提供一个独立于测试服务进程(yqsrv_testd)的"消息通道"

| ID | 数据 | 说明 |
| ---- | ---- | ---- |
| 0x1CF00001| 00 00 00 00 00 00 00 00 |对数据域没有要求|
| 0x1CF10001| 同上 | 同上 |

如下脚本是其中一种方式:

```sh
#!/bin/sh
id=1cf00001
while [ true ]
do
  cansend can0 $id#1c.f0.33.44.55.66.77.88
  msleep 100
  cansend can1 $id#1c.f0.33.44.55.66.77.88
  msleep 100
  cansend can2 $id#1c.f0.33.44.55.66.77.88
  msleep 100
done
```

注1:每一台被测设备具有不同源地址,所以CAN ID 采用 0x1CF000xx,最低字节填充为被测设备地址(从0x01开始)
注2:两个脚本在Init过程的不同位置启动,分别发出不同ID有利于区分启动的不同阶段


## 测试控制器(诊断测试)

### 测试客户端进程 (Spy-station)

运行于"非被测设备"的用户进程,通常一个测试环境下仅包含唯一设备运行该进程.该进程

#### 启动客户端进程

通过 -c 参数指定测试脚本,以实现不同的测试动作,检查点序列的快速切换.

```sh
# ./Spy-station -c general.process
```

#todo-Dev 
- [x]  清理异常标记,不能按参数记录,64位不够,需要大类记录,然后通过详细event记录查看错误情况
- [x] 在测试脚本中设置被测设备数量


#### 测试脚本(*.process)

通过该脚本可以比较方便的定义动作,脚本中每一行描述一个测试动作,格式如下:
> <时刻>:<动作内容>:<参数>

1. 时刻,最小分辨时间ms
2. 内容,具体的测试动作包括以下:

> - 控制,控制外部设备,比如CAN扩展开关,比如:POWER_ON_ACC
> - 获取,从被测设备中请求指定参数,比如:GET_CPU_ID
> - 设置,设定被测设备中的指定参数,比如:SET_BACKLIGHT_OFF
> - 检查点,检查特定判断条件,在确认数据异常时随时记录,比如:CHECK_BACKLIGHT
> - 记录,向过程文件中添加一条记录,比如:RECORD_PROFILE

3. 参数,部分测试动作可指定参数,比如设置背光

> ```sh
> 30600:SET_BACKLIGHT_ON:255 //设置被测设备背光亮度为255
> 30700:RANDOM_POWEROFF:5    //设置最大随机关机时间为5s,并开始计时
> ```

如下测试脚本:
```sh
100:SET_ACC_BIT:1          //100ms时,指定CAN扩展开关的ACC电源通道
200:SET_BAT_BIT:2          //200ms时,指定CAN扩展开关的BAT电源通道
300:POWER_ON_BAT:1         //300ms时,打开BAT电源
400:POWER_ON_ACC:1         //400ms时,打开ACC电源
500:ENABLE_CAN0_TX:1       //500ms时,启动CAN0压力发送

26000:GET_CPU_ID:1         //26s时,读取SOC的CPUID
26100:GET_UPTIME:1         //26.1s时,读取设备启动时间(sec)
....
39400:CHECK_BACKLIGHT:1    //39.4s时,检查背光亮度是否符合预期(acc,bat状态决定)
39500:RECORD_PROFILE:1     //39.5s时,向过程文件添加一条记录
....
39900:POWER_OFF_ACC:1      //39.9s时,关闭ACC
49500:POWER_OFF_BAT:1      //49.5s时,关闭BAT
49900:AFTER_POWEROFF:1     //49.9s时,执行本次循环的"后处理",可控制下次开机的间隔时间
```

##### 系统测试命令

|脚本命令|功能|说明|
|--|--|--|
|GET_CPU_ID              | 请求CPU ID ||
|GET_UPTIME              | 请求系统启动时间||
|GET_CPU_TEMP            | 请求CPU温度||
|GET_LOADAGE_1MIN        | 请求系统平均负载||
|GET_CPU_FREQ_0          | 请求CPU0主频||
|GET_AVAILD_MEM          | 请求当前可用内存||
|GET_CAN0_RX             | 请求CAN0接收帧计数||
|GET_CAN0_TX             | 请求CAN0发送帧计数||
|GET_BL_SENSOR           | 请求外部亮度传感器状态||
|GET_BACKLIGHT           | 请求系统背光亮度值||

##### yqsrv_ignition(Orchid)服务进程测试命令

|脚本命令|功能|说明|
|--|--|--|
|GET_ORCHID_ACC          | 请求Orchid获取的ACC状态||

##### yqsrv_launcher(Launcher)服务进程测试命令

|脚本命令|功能|说明|
|--|--|--|
|GET_LAUNCHER_RESTART    | 请求Launcher累计重启其他进程的计数||
|GET_LAUNCHER_HEARTBEAT  | 请求Launcher运行心跳计数||

##### yqsrv_hourmeter(Hyman)服务进程测试命令

|脚本命令|功能|说明|
|--|--|--|
|GET_HM_ZL               | 请求小时计(中联)秒计数||
|GET_HM_LV               | 请求小时计(雷沃)秒计数||
|GET_HM                  | 请求小时计秒计数||

##### 触摸屏测试命令

|脚本命令|功能|说明|
|--|--|--|
|GET_TS_PRESS            | 请求触摸屏按下计数||
|GET_TS_RELEASE          | 请求触摸屏释放计数||
|GET_TS_X                | 请求触摸X坐标||
|GET_TS_Y                | 请求触摸Y坐标||
|CHECK_TOUCH_MISMATCH_LT             | 检查触摸屏按下和释放的匹配误差小于指定参数 |>0 |

##### yqsrv_keypad(Kemp)服务进程测试命令

|脚本命令|功能|说明|
|--|--|--|
|GET_F1_PRESSED          | 请求Kemp进程的CAN键盘F1键按下计数||
|GET_F1_RELEASE          | 请求Kemp进程的CAN键盘F1键释放计数||

##### MCU测试命令

| 脚本命令 | 功能 | 说明 |
| ---- | ---- | ---- |
| GET_MCU_SW_MAJOR | 请求MCU固件主版本号 |  |
| GET_MCU_SW_MINOR | 请求MCU固件次版本号 |  |
| GET_MCU_HW_MAJOR | 请求MCU硬件主版本号 |  |
| GET_MCU_HW_MINOR | 请求MCU硬件次版本号 |  |
| GET_MCU_ACC_VOLTAGE | 请求MCU采集ACC电压 |  |
| GET_MCU_BAT_VOLTAGE | 请求MCU采集BAT电压 |  |
| CHECK_MCU | 检查MCU |  弃用 |
| CHECK_ACC_VOLTAGE_GE | 检查ACC大于设置值 |当小于目标值时记录异常  |
| CHECK_BAT_VOLTAGE_GE | 检查BAT大于设置值 |当小于目标值时记录异常  |
| CHECK_ACC_VOLTAGE_LT | 检查ACC小于设置值 |当大于目标值时记录异常  |
| CHECK_BAT_VOLTAGE_LT | 检查BAT小于设置值 |当大于目标值时记录异常  |

示例:检查 MCU  采样 ACC 电压是否符合预期
脚本设定如下:启动后20s请求MCU ACC电压,比较是否大于24v (当前12v)

```
20000:GET_MCU_ACC_VOLTAGE:1  
21000:GET_MCU_ACC_VOLTAGE:1  
24000:CHECK_ACC_VOLTAGE_GE:24000

// Spy.event 记录异常如下:
{24-3-1 15:6:1.559} Starting... 
{24-3-1 15:6:35.688} Dev[0] MCU ACC voltage 11487 less than 24000
```


##### 背光测试命令

|脚本命令|功能|说明|
|--|--|--|
|GET_BL_SENSOR           | 请求外部亮度传感器状态||
|GET_BACKLIGHT           | 请求系统背光亮度值||
|CHECK_BACKLIGHT_STATUS         | 对比检查传感器采样的背光状态与参数指定状态 |0,1 |
|SET_BACKLIGHT       | 设置背光亮度|0~255|
|        |  ||

##### CAN测试命令

|脚本命令|功能|说明|
|--|--|--|
|ENABLE_CAN0_TX          | 启动CAN0压力发送||
|ENABLE_CAN1_TX          | 启动CAN1压力发送||
|DISABLE_CAN0_TX         | 关闭CAN0压力发送||
|DISABLE_CAN1_TX         | 关闭CAN0压力发送||
|CHECK_CAN               | 检查CAN状态||

##### 电源控制命令

| 脚本命令 | 功能 | 说明 |
| ---- | ---- | ---- |
| SET_ACC_BIT | 设置CAN扩展开关的ACC位置 | CH0=1,CH1=2,CH3=4... |
| SET_BAT_BIT | 设置CAN扩展开关的BAT位置 | CH0=1,CH1=2,CH3=4... |
| POWER_ON_BAT | 打开BAT电源 |  |
| POWER_ON_ACC | 打开ACC电源 |  |
| POWER_OFF_ACC | 关闭ACC电源 |  |
| POWER_OFF_BAT | 关闭BAT电源 |  |
| RANDOM_POWEROFF | 启动随机关机过程 | 设置最大随机时间:0~10000s |
| SET_DEVICE_NUM | 设置被测试设备数量 | 0~32 |

范例:

```sh
100:SET_DEVICE_NUM:1  // 设置被测试设备数量为1
200:SET_ACC_BIT:1     // 设置CAN模块的ACC控制位
300:SET_BAT_BIT:2     // 设置CAN模块的BAT控制位
400:POWER_ON_BAT:1    // 打开BAT
500:POWER_ON_ACC:1    // 打开ACC
....
33000:POWER_OFF_ACC:1 // 关闭ACC
38000:POWER_OFF_BAT:1 // 关闭BAT
39000:AFTER_POWEROFF:1// 测试后处理
```

##### 其他控制命令

|脚本命令|功能|说明|
|--|--|--|
|RECORD_PROFILE          | 记录当前时刻测试数据||
|EXABLE_QUIT_EXCEPTION   | 使能异常退出功能 | 设置为1时,当CHECK函数发生异常时将退出测试过程,保持当前ACC/BAT的状态|

##### 显示像素测试命令

| 脚本命令 | 功能 | 说明 |
| ---- | ---- | ---- |
| GET_PIEXL_COLOR | 请求指定位置的像素颜色 |  |
| SET_PIEXL_X | 设置目标像素X位置 |  |
| SET_PIEXL_Y | 设置目标像素Y位置 |  |
| CHECK_COLOR_CHANGED | 检查指定位置像素颜色是否改变 | 当多次检查无改变时,满足max_color_changed 指定阈值,触发异常记录  |
| MAX_COLOR_CHANGED | 指定累计颜色无改变的计数值 |   |

像素颜色的检查功能的说明:

 1. 首先通过 SET_PIEXL_X/Y 指定目标像素位置,一次启动只需设置一次
 2. 通过 CHECK_COLOR_CHANGED 检查指定像素位置的颜色与上一次采样相比是否改变,当累计多次未改变后可记录异常
 3. 设置MAX_COLOR_CHANGED 参数,指定在记录"颜色未改变异常"前的累计"未改变"次数,默认为1次.由于当前测试采用摄像头的白平衡振荡形成的颜色改变,所以确实有可能采样时刻与振荡频率稳定关系,导致存在"假采样"的情况,所以需要添加多次判断.

范例:

```sh
100:SET_DEVICE_NUM:1  // 设置被测试设备数量为1
200:SET_ACC_BIT:1     // 设置CAN模块的ACC控制位
300:SET_BAT_BIT:2     // 设置CAN模块的BAT控制位
400:POWER_ON_BAT:1    // 打开BAT
500:POWER_ON_ACC:1    // 打开ACC
600:ENABLE_QUIT_EXCEPTION:1   // 设置异常退出
700:MAX_COLOR_CHANGED:5       // 设置颜色未改变时累计5次记录异常

21000:GET_PIEXL_COLOR:1       // 请求颜色
21100:CHECK_COLOR_CHANGE:0    // 第一次检查颜色改变

23200:GET_PIEXL_COLOR:1
23500:CHECK_COLOR_CHANGE:0

25400:GET_PIEXL_COLOR:1
25500:CHECK_COLOR_CHANGE:0

27600:GET_PIEXL_COLOR:1
27700:CHECK_COLOR_CHANGE:0

29800:GET_PIEXL_COLOR:1
29900:CHECK_COLOR_CHANGE:0

32000:GET_PIEXL_COLOR:1
32100:CHECK_COLOR_CHANGE:0    // 第6次检查颜色改变

33000:POWER_OFF_ACC:1         // 关闭ACC
38000:POWER_OFF_BAT:1         // 关闭BAT
39000:AFTER_POWEROFF:1        // 测试后处理
```

 
#### 测试记录

测试过程中将采用以下方式记录:异常事件,过程和其他证据

|文件名|功能|说明|
|--|--|--|
|Spy.event|用于记录"check"过程中判断的异常事件|文本 |
|Spy.stats|用于记录测试执行统计数据 |二进制 |
|dev_x/date.cvs|用于记录指定设备的测试过程数据|文本 |

如下,在 /home/root/Spy/ 目录下保存测试过程记录文件
```sh
Spy.event
Spy.stats
dev_0/
```

##### 事件记录

测试过程中,在动作/检查函数中已添加部分异常事件的识别,比如在ACC和BAT均保持供电时,排除程序关闭背光的情况,若"亮度传感器"反馈为0,则判断为背光控制异常,将会在 Spy.event 文件中记录.类似的,若启动后触摸屏持续未发生按下/释放,也会触发事件记录,如下:

```sh
// 测试启动,触摸屏异常,按下和释放计数为0
{24-2-26 8:50:5.723} Starting...
{24-2-26 8:50:48.483} Dev[0] Touch Pressed is ZERO
{24-2-26 8:50:48.508} Dev[0] Touch Released is ZERO
```

##### 过程参数记录

测试过程中,根据脚本描述的记录动作(RECORD_PROFILE),向 Spy/dev_x/yy-mm-dd.cvs 写入一条记录,该条目记录被测设备的所有数据(已通过脚本请求的内容),外部总线负载,亮度传感器状态等.如下:

如下所示,在 /home/root/Spy/dev_x/ 路径下,测试过程的记录数据写入以"日期"为名的cvs文件中.每天添加一份记录文件便于按天检查.

```sh
root@colibri-imx6:~/Spy/dev_0# ls -al
24-2-18.cvs
24-2-19.cvs
```

\*.cvs 文件内的记录如下,采用"空格+逗号"分割记录条目,便于该表格可以被 execl/wps 等表格工具查看,通过"列分割"后即可成为标准的数据表格用于统计分析.

```sh
Info, 2024-02-26, 08:52:23, 0, 4532, 0:0:39, 65:0:29, 82.89, 0.41, 1, 1, 0, 0, 1, 1, 1, 1442628436, 24, 2
```

##### 视频或图片记录

作为显示器,存在部分内部状态和外部显示效果可以相互校验的条件,对这部分参数的异常状态的校验可辅助视频或是拍照截图的方式记录.
目前已在部分 Check 动作中添加异常拍照过程,拍摄照片位于 /home/root/ 或 /home/root/Spy/ 路径下,文件名采用"event_type#date_time.jpg"定义,该event_type及时间可在Spy/Spy.event 筛选相关记录.
如下记录了一次"背光异常",event类型是 BL_Err,记录时间是 2024-2-23_17:3:24.

```sh
root@colibri-imx6:~# ls -l
BL_Err#2024-2-23_17:3:24.jpg
```

## CAN扩展IO

由于采用imx6显示器承担测试控制的角色,而显示器本身不具备IO能力,所以需要添加外部设备作为控制执行机构,目前采用广东东莞中盛科技的CAN扩展输入输出模块.该模块采用CAN总线数据控制开关量输出,且可通过CAN请求获得开关量输入状态.

### 开关量输出

通过CAN发出如下扩展帧,即可控制对应通道输出状态.

|ID|Data|说明|
|--|--|--|
|0x00AA0101|Byte[0:7]| Ch0=Byte[0]^0, Ch1=Byte[0]^1...|

**晶体管输出模块,两路公共端必须链接,其中COM+需要链接电源,COM-需要链接GND**

### 开关量输入

通过CAN发出如下扩展帧,开关模块即通过同一ID返回当前开关输入状态.

|ID|Data|说明|
|--|--|--|
|0x00AA0301|Byte[0:7]=0| 等待由扩展模块返回同一ID的数据标记当前开关量输入状态|

> 由于亮度传感器以5V作为工作电源,输出开关信号的幅值也被限制为5V以下,而开关量输入模块是按照12V/24V设计的,若通过输入通道采集外部亮度传感器,则需要修改开关量输入模块的硬件电路:
> 1. 从开关输入模块取5v电源输出到亮度传感器
> 2. 亮度传感器的输入通道,需要调整光耦输入的电路参数或直接跨过光耦进入MCU.

## 生产测试工具(Hunter,硬件测试)
待完成
